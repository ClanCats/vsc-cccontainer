{"version":3,"file":"extension.js","mappings":"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","sources":["webpack://cccontainer/./src/CtnCompletionProvider.ts","webpack://cccontainer/external commonjs \"vscode\"","webpack://cccontainer/external node-commonjs \"child_process\"","webpack://cccontainer/external node-commonjs \"fs\"","webpack://cccontainer/external node-commonjs \"os\"","webpack://cccontainer/external node-commonjs \"path\"","webpack://cccontainer/webpack/bootstrap","webpack://cccontainer/./src/extension.ts"],"sourcesContent":["import * as vscode from 'vscode';\nimport * as fs from 'fs';\nimport * as os from 'os';\nimport * as ospath from 'path';\nimport { execSync, spawn } from 'child_process';\n\nconst availableServices: string[] = [];\nconst availableParamterKeys: string[] = [];\nlet lastContainerCacheScan = 0;\n\nfunction uniquifyAvailableServices() {\n    const uniqueAvailableServices = new Set(availableServices);\n    availableServices.length = 0;\n    availableServices.push(...uniqueAvailableServices);\n}\n\nfunction scanContainerCacheFile() {\n    const cachePath = vscode.workspace.workspaceFolders?.[0].uri.fsPath + '/var/cache/AppContainer.php';\n    // check if the cache file has been modifed since last scan\n    const cacheFileStats = fs.statSync(cachePath);\n    if (cacheFileStats.mtimeMs > lastContainerCacheScan) {\n        lastContainerCacheScan = cacheFileStats.mtimeMs;\n\n        // read the file\n        const cacheFile = fs.readFileSync(cachePath, 'utf8');\n\n        // check if we can access a php binary, if none is configured\n        // we check if the binary is in the current $PATH   \n        let phpBinary: string | undefined = vscode.workspace.getConfiguration('ctn').get('phpBinary');\n        if (!phpBinary) {\n            phpBinary = execSync('which php').toString().trim();\n\n            // if the returned string is empty or \"php not found\" we can't use php and \n            // just continue the scan without php\n            if (phpBinary === '' || phpBinary === 'php not found') {\n                scanContainerCacheFileWithoutPHP(cachePath, cacheFile);\n                return;\n            }\n\n            // update the php binary setting\n            vscode.workspace.getConfiguration('ctn').update('phpBinary', phpBinary, true);\n        }\n\n        // use php to get the service names\n        scanContainerCacheFileWithPHP(cachePath, cacheFile, phpBinary.trim());\n    }\n}\n\nfunction scanContainerCacheFileWithoutPHP(path: string, contents: string) {\n    const serviceResolverTypeLine = contents.match(/protected array \\$serviceResolverType = \\[.*\\]/g);\n\n    // just use a regex to find all service names\n    if (serviceResolverTypeLine && serviceResolverTypeLine.length > 0) {\n        const serviceNameMatches = serviceResolverTypeLine[0].matchAll(/'([a-zA-Z\\._]+)'/g);\n        for (const serviceName of serviceNameMatches) {\n            availableServices.push(serviceName[1]);\n        }\n    }\n\n    uniquifyAvailableServices();\n}\n\nfunction scanContainerCacheFileWithPHP(path: string, contents: string, phpBinary: string) {\n    // first determine the container class name\n    const matches = contents.matchAll(/class ([A-Za-z]+) extends ClanCatsContainer/g);\n    const containerClassName = matches.next().value[1];\n    if (!containerClassName || containerClassName.length === 0) {\n        // if we can't determine the container class name we can't use php\n        scanContainerCacheFileWithoutPHP(path, contents);\n        return;\n    }\n\n    // remove the \"extends ClanCatsContainer\" part from the code\n    contents = contents.replace(/extends ClanCatsContainer[0-9a-z]+/g, '');\n\n    // create a temporary php file\n    const tempDir = os.tmpdir();\n    const tempFile = ospath.join(tempDir, 'ctn_' + Math.random().toString(36).substring(2) + '.php');\n\n    if (fs.existsSync(tempFile)) {\n        fs.unlinkSync(tempFile);\n    }\n\n    let phpExtractionCode = `\n    // make all properties accessible\n    $containerRefl = new ReflectionClass(${containerClassName}::class);\n    foreach ($containerRefl->getProperties() as $property) {\n        $property->setAccessible(true);\n    }\n\n    $container = new ${containerClassName}();\n    \n    // get the paramters\n    $data = [];\n    $data['parameters'] = $containerRefl->getProperty('parameters')->getValue($container);\n\n    // get the services\n    $data['services'] = $containerRefl->getProperty('serviceResolverType')->getValue($container);\n\n    echo json_encode($data);\n    `;\n\n    // dump the container code into the temporary file\n    fs.writeFileSync(tempFile, contents + phpExtractionCode);\n\n    // run the php code\n    const result = execSync(phpBinary + ' ' + tempFile).toString();\n\n    // try to decode the result\n    try {\n        const data = JSON.parse(result);\n\n        // assign the available parameters\n        availableParamterKeys.push(...Object.keys(data.parameters));\n\n        // assign the available services\n        availableServices.push(...Object.keys(data.services));\n\n        // console.log(data);\n\n        uniquifyAvailableServices();\n    } catch (e) {\n        console.error('error: ' + e);\n    }\n}\n\nexport class CtnCompletionProvider implements vscode.CompletionItemProvider<vscode.CompletionItem> {\n\n    provideCompletionItems(\n        document: vscode.TextDocument, position: vscode.Position,\n        token: vscode.CancellationToken, context: vscode.CompletionContext\n    ): vscode.ProviderResult<vscode.CompletionItem[]> {\n        scanContainerCacheFile();\n\n        // figure out if the cursor is currently in parameter or service context\n        const linePrefix = document.lineAt(position).text.substr(0, position.character);\n        \n        const serviceRegex = /@([a-zA-Z0-9\\._]+)?$/;\n        const parameterRegex = /:([a-zA-Z0-9\\._]+)?$/;\n\n        if (serviceRegex.test(linePrefix)) {\n            // match the prefix and use it as a filter\n            const match: string = linePrefix.match(serviceRegex)?.[0].substring(1) ?? '';\n\n            const createCompletionItem = (str: string) => {\n                let item = new vscode.CompletionItem(str, vscode.CompletionItemKind.Class);\n                // range is based on the match\n                item.range = new vscode.Range(position.line, position.character - match.length, position.line, position.character);\n                return item;\n            }\n\n            // no specific service name was typed yet so just return all available services\n            if (match.length === 0) {\n                return availableServices.map((str) => createCompletionItem(str));\n            }\n        \n            return availableServices\n                .filter((str) => str.startsWith(match))\n                .map((str) => createCompletionItem(str));\n        }\n\n        if (parameterRegex.test(linePrefix)) {\n            // match the prefix and use it as a filter\n            const match: string = linePrefix.match(parameterRegex)?.[0].substring(1) ?? '';\n\n            const createCompletionItem = (str: string) => {\n                let item = new vscode.CompletionItem(str, vscode.CompletionItemKind.Class);\n                // range is based on the match\n                item.range = new vscode.Range(position.line, position.character - match.length, position.line, position.character);\n                return item;\n            };\n\n            // no specific parameter name was typed yet so just return all available parameters\n            if (match.length === 0) {\n                return availableParamterKeys.map((str) => createCompletionItem(str));\n            }\n\n            return availableParamterKeys\n                .filter((str) => str.startsWith(match))\n                .map((str) => createCompletionItem(str));\n        }\n\n        return undefined;\n    }\n\n    // findAtStrings(document) {\n    //     const regex = /@[A-Za-z0-9\\.\\_]+/g;\n    //     const atStrings = new Set();\n    //     const text = document.getText();\n\n    //     let match;\n    //     while ((match = regex.exec(text)) !== null) {\n    //         atStrings.add(match[0]);\n    //     }\n\n    //     return Array.from(atStrings);\n    // }\n}","module.exports = require(\"vscode\");","module.exports = require(\"child_process\");","module.exports = require(\"fs\");","module.exports = require(\"os\");","module.exports = require(\"path\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","import * as vscode from 'vscode';\nimport { CtnCompletionProvider } from './CtnCompletionProvider';\n\nexport function activate(context: vscode.ExtensionContext) \n{\n    const selector = { scheme: 'file', language: 'ctn' };\n    context.subscriptions.push(\n        vscode.languages.registerCompletionItemProvider(selector, new CtnCompletionProvider(), '@', ':')\n    );\n}\n\n// This method is called when your extension is deactivated\nexport function deactivate() {}\n"],"names":["availableServices","availableParamterKeys","lastContainerCacheScan","uniquifyAvailableServices","uniqueAvailableServices","Set","length","push","scanContainerCacheFileWithoutPHP","path","contents","serviceResolverTypeLine","match","serviceNameMatches","matchAll","serviceName","provideCompletionItems","document","position","token","context","cachePath","vscode","workspace","workspaceFolders","uri","fsPath","cacheFileStats","fs","statSync","mtimeMs","cacheFile","readFileSync","phpBinary","getConfiguration","get","execSync","toString","trim","update","containerClassName","next","value","replace","tempDir","os","tmpdir","tempFile","ospath","join","Math","random","substring","existsSync","unlinkSync","phpExtractionCode","writeFileSync","result","data","JSON","parse","Object","keys","parameters","services","e","console","error","scanContainerCacheFileWithPHP","scanContainerCacheFile","linePrefix","lineAt","text","substr","character","serviceRegex","parameterRegex","test","createCompletionItem","str","item","CompletionItem","CompletionItemKind","Class","range","Range","line","map","filter","startsWith","module","exports","require","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","subscriptions","languages","registerCompletionItemProvider","scheme","language","CtnCompletionProvider"],"sourceRoot":""}